I apologize for the confusion earlier. Let's correct the logic once more to ensure that we handle all edge cases correctly.

The issue lies in how the problem specifies "nearest." When `N` is exactly halfway between two multiples of 100 (i.e., when \( N \% 100 = 50 \)), the problem states that we should print the bigger number, which means we need to round up to the next multiple of 100 ending in 99.

Here's the corrected code:

```python
# Read input from standard input
N = int(input())

# Calculate the nearest number ending in 99
if N % 100 <= 50:
    closest_number = N - (N % 100)
else:
    closest_number = N + (100 - N % 100)

# Ensure the result ends in 99 if it's exactly halfway between two multiples of 100
if N % 100 == 50:
    closest_number += 50

# Print the result
print(closest_number)
```

This code should now correctly handle all edge cases and pass the test cases. Specifically, when \( N \% 100 = 50 \), it ensures that we round up to the next multiple of 100 ending in 99.